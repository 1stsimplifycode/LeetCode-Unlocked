# 924. [Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approach 1: Depth First Search (DFS) to Identify Components

### Solution
python
```python
# Time Complexity: O(n^2)
# Space Complexity: O(n)

class Solution:
    def minMalwareSpread(self, graph, initial):
        def dfs(node, color):
            colors[node] = color
            for nei, is_connected in enumerate(graph[node]):
                if is_connected == 1 and colors[nei] == -1:
                    dfs(nei, color)

        N = len(graph)
        colors = [-1] * N
        color = 0

        # Use DFS to mark each connected component with a unique color
        for node in range(N):
            if colors[node] == -1:
                dfs(node, color)
                color += 1

        size = [0] * color  # Size of each component
        for c in colors:
            size[c] += 1

        colorCount = [0] * color  # Count of malware in each component
        for node in initial:
            colorCount[colors[node]] += 1

        result = float('inf')
        for node in initial:
            c = colors[node]
            # Check if removing this node would minimize the malware spread
            if colorCount[c] == 1:
                if (result == float('inf') or size[c] > size[colors[result]] 
                        or (size[c] == size[colors[result]] and node < result)):
                    result = node

        # If no such node is found, return the smallest index node
        if result == float('inf'):
            result = min(initial)

        return result
```

## Approach 2: Union-Find to Identify Components

### Solution
python
```python
# Time Complexity: O(n^2)
# Space Complexity: O(n)

class Solution:
    def minMalwareSpread(self, graph, initial):
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])  # Path compression
            return parent[x]

        def union(x, y):
            rootX = find(x)
            rootY = find(y)
            if rootX != rootY:
                if size[rootX] > size[rootY]:
                    parent[rootY] = rootX
                    size[rootX] += size[rootY]
                else:
                    parent[rootX] = rootY
                    size[rootY] += size[rootX]

        N = len(graph)
        parent = list(range(N))
        size = [1] * N

        # Union-Find to identify components
        for i in range(N):
            for j in range(N):
                if graph[i][j] == 1:
                    union(i, j)

        colorCount = [0] * N
        for node in initial:
            colorCount[find(node)] += 1

        initial.sort()
        result = initial[0]
        maxComponentSize = 0

        for node in initial:
            root = find(node)
            if colorCount[root] == 1:
                if size[root] > maxComponentSize:
                    maxComponentSize = size[root]
                    result = node

        return result
```

These approaches provide solutions using DFS and Union-Find to identify connected components and compute the best node to remove to minimize malware spread.

