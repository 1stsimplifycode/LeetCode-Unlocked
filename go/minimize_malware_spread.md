# 924. [Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approach 1: Depth First Search (DFS) to Identify Components

### Solution
go
```go
// Time Complexity: O(n^2)
// Space Complexity: O(n)
import "math"

func minMalwareSpread(graph [][]int, initial []int) int {
    N := len(graph)
    colors := make([]int, N)
    for i := 0; i < N; i++ {
        colors[i] = -1
    }
    color := 0

    // Use DFS to mark each connected component with a unique color
    for node := 0; node < N; node++ {
        if colors[node] == -1 {
            dfs(graph, colors, node, color)
            color++
        }
    }

    size := make([]int, color) // Size of each component
    for _, c := range colors {
        size[c]++
    }

    colorCount := make([]int, color) // Count of malware in each component
    for _, node := range initial {
        colorCount[colors[node]]++
    }

    result := math.MaxInt32
    for _, node := range initial {
        c := colors[node]
        // Check if removing this node would minimize the malware spread
        if colorCount[c] == 1 {
            if result == math.MaxInt32 || size[c] > size[colors[result]] || (size[c] == size[colors[result]] && node < result) {
                result = node
            }
        }
    }

    // If no such node is found, return the smallest index node
    if result == math.MaxInt32 {
        result = initial[0]
        for _, node := range initial {
            if node < result {
                result = node
            }
        }
    }

    return result
}

// DFS function to mark each node with its component's color
func dfs(graph [][]int, colors []int, node int, color int) {
    colors[node] = color
    for nei := 0; nei < len(graph); nei++ {
        if graph[node][nei] == 1 && colors[nei] == -1 {
            dfs(graph, colors, nei, color)
        }
    }
}
```

## Approach 2: Union-Find to Identify Components

### Solution
go
```go
// Time Complexity: O(n^2)
// Space Complexity: O(n)
import (
    "sort"
)

func minMalwareSpread(graph [][]int, initial []int) int {
    N := len(graph)
    parent := make([]int, N)
    size := make([]int, N)

    // Initialize the parent and size arrays for Union-Find
    for i := 0; i < N; i++ {
        parent[i] = i
        size[i] = 1
    }

    // Union-Find to identify components
    for i := 0; i < N; i++ {
        for j := 0; j < N; j++ {
            if graph[i][j] == 1 {
                union(i, j, parent, size)
            }
        }
    }

    colorCount := make([]int, N)
    for _, node := range initial {
        colorCount[find(node, parent)]++
    }

    sort.Ints(initial)
    result := initial[0]
    maxComponentSize := 0

    for _, node := range initial {
        root := find(node, parent)
        if colorCount[root] == 1 {
            if size[root] > maxComponentSize {
                maxComponentSize = size[root]
                result = node
            }
        }
    }

    return result
}

// Find function for Union-Find
func find(x int, parent []int) int {
    if parent[x] != x {
        parent[x] = find(parent[x], parent) // Path compression
    }
    return parent[x]
}

// Union function for Union-Find
func union(x int, y int, parent []int, size []int) {
    rootX := find(x, parent)
    rootY := find(y, parent)

    if rootX != rootY {
        if size[rootX] > size[rootY] {
            parent[rootY] = rootX
            size[rootX] += size[rootY]
        } else {
            parent[rootX] = rootY
            size[rootY] += size[rootX]
        }
    }
}
```

These approaches provide solutions using DFS and Union-Find to identify connected components and compute the best node to remove to minimize malware spread.

