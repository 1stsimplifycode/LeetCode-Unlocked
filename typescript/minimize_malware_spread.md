# 924. [Minimize Malware Spread](https://leetcode.com/problems/minimize-malware-spread/)

## Approach 1: Depth First Search (DFS) to Identify Components

### Solution
typescript
```typescript
// Time Complexity: O(n^2)
// Space Complexity: O(n)

function minMalwareSpread(graph: number[][], initial: number[]): number {
    const N = graph.length;
    const colors = new Array(N).fill(-1);
    let color = 0;

    // Use DFS to mark each connected component with a unique color
    for (let node = 0; node < N; ++node) {
        if (colors[node] === -1) {
            dfs(graph, colors, node, color++);
        }
    }

    const size = new Array(color).fill(0); // Size of each component
    for (const c of colors) {
        size[c]++;
    }

    const colorCount = new Array(color).fill(0); // Count of malware in each component
    for (const node of initial) {
        colorCount[colors[node]]++;
    }

    let result = Infinity;
    for (const node of initial) {
        const c = colors[node];
        // Check if removing this node would minimize the malware spread
        if (colorCount[c] === 1) {
            if (
                result === Infinity || 
                size[c] > size[colors[result]] || 
                (size[c] === size[colors[result]] && node < result)
            ) {
                result = node;
            }
        }
    }

    // If no such node is found, return the smallest index node
    if (result === Infinity) {
        result = Math.min(...initial);
    }

    return result;
}

// DFS function to mark each node with its component's color
function dfs(graph: number[][], colors: number[], node: number, color: number): void {
    colors[node] = color;
    for (let nei = 0; nei < graph.length; ++nei) {
        if (graph[node][nei] === 1 && colors[nei] === -1) {
            dfs(graph, colors, nei, color);
        }
    }
}
```

## Approach 2: Union-Find to Identify Components

### Solution
typescript
```typescript
// Time Complexity: O(n^2)
// Space Complexity: O(n)

function minMalwareSpreadUnionFind(graph: number[][], initial: number[]): number {
    const N = graph.length;
    const parent = Array.from({ length: N }, (_, i) => i);
    const size = new Array(N).fill(1);

    // Union-Find to identify components
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            if (graph[i][j] === 1) {
                union(i, j, parent, size);
            }
        }
    }

    const colorCount = new Array(N).fill(0);
    for (const node of initial) {
        colorCount[find(node, parent)]++;
    }

    initial.sort((a, b) => a - b);
    let result = initial[0];
    let maxComponentSize = 0;

    for (const node of initial) {
        const root = find(node, parent);
        if (colorCount[root] === 1) {
            if (size[root] > maxComponentSize) {
                maxComponentSize = size[root];
                result = node;
            }
        }
    }

    return result;
}

// Find function for Union-Find
function find(x: number, parent: number[]): number {
    if (parent[x] !== x) {
        parent[x] = find(parent[x], parent); // Path compression
    }
    return parent[x];
}

// Union function for Union-Find
function union(x: number, y: number, parent: number[], size: number[]): void {
    const rootX = find(x, parent);
    const rootY = find(y, parent);

    if (rootX !== rootY) {
        if (size[rootX] > size[rootY]) {
            parent[rootY] = rootX;
            size[rootX] += size[rootY];
        } else {
            parent[rootX] = rootY;
            size[rootY] += size[rootX];
        }
    }
}
```

These approaches provide solutions using DFS and Union-Find to identify connected components and compute the best node to remove to minimize malware spread.

